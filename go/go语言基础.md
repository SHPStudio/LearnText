# Go语言基础
## 变量声明
`var [名称] [类型]`
eg: `var a, b *int` 表示a,b为int的指针类型

go语言的基本类型：
- bool
- string
- int int8 int16 int32 int64
- uint uint8 uint16 uint32 uint64 uintptr
- byte // uint8的别名 
- rune // int32的别名代表一个Unicode码
- float32 float64
- complex64 complex128

变量声明后，系统自动赋予该类型的零值，int为0，float为0.0 bool为false string为空字符串 指针为nil。

变量命名遵循驼峰命名

变量声明的几种方式：
- var [名字] [类型]
- 批量
```
var (
  a int
  b string
  c []float32
  d func() bool
  e struct {
     x int
  }
)
```
- 简短格式 `名字:=表达式`，不过它有一些限制 
1. 定义变量同时需要显式初始化
2. 不能提供数据类型
3. 只能用在函数内部

## 匿名变量
`_`，任何赋给该特殊标识符的变量的值都会被抛弃，后续代码也无法使用或者进行某些运算。
匿名变量不占用命名空间，不会分配内存。

## 内置类型
内置类型是由语言提供的一组类型。它们分别是数值类型、字符串类型和布尔类型。这些类型本质上是原始的类型。因此，当对这些值进行增加或者删除的时候，会创建一个新值。所以，当把这些类型的值传递给方法时，应该传递一个对应值的副本。同样的string类型本质也是一种很原始的数据值，也应该传递字符串的副本。

## 引用类型
Go的引用类型类型：切片(数组),映射(map)，通道，接口和函数类型。声明上述变量时，创建的变量被称为标头值(指针)。

引用类型的值如果像原始类型一样传入方法或者函数`xxxfunc(ip IP(引用类型))`，就代表是传入了该引用类型值的副本，并不是应用类型本身。

是否传递引用类型使用指针`*`，这个要看该引用类型本质上是否属于原始类型，属于不可变结构。如果属于不可变结构完全可以当成原始类型来使用。例子如下
```
type Time struct {
    // sec 给出自公元 1 年1 月1 日00:00:00
    // 开始的秒数
    sec int64

    // nsec 指定了一秒内的纳秒偏移，
    // 这个值是非零值，
    // 必须在[0, 999999999]范围内
    nsec int32

    // loc 指定了一个Location，
    // 用于决定该时间对应的当地的分、小时、
    // 天和年的值
    // 只有Time 的零值，其loc 的值是nil
    // 这种情况下，认为处于UTC 时区
    loc *Location
}
```
该时间结构体本身就属于不可更改的对象。所以可以当作原始类型来对待。
```
func Now() Time {
    sec, nsec := now()
    return Time{sec + unixToInternal, nsec, Local}
}
```
Now方法的实现就没有通过使用指针让Time值共享，而是返回了Time值的副本。
```

```

如果本身带有可变的属性，例如本身结构带有指针类型。
